// src/utils/dashboardUtils.js - UTILIDADES PARA EL DASHBOARD
import { format, subDays, startOfDay, endOfDay } from 'date-fns'
import { es } from 'date-fns/locale'

// ✅ Formatear moneda peruana
export const formatCurrency = (amount, currency = 'PEN') => {
  return new Intl.NumberFormat('es-PE', {
    style: 'currency',
    currency,
    minimumFractionDigits: 2
  }).format(amount || 0)
}

// ✅ Formatear porcentajes
export const formatPercentage = (value, decimals = 1) => {
  return `${(value || 0).toFixed(decimals)}%`
}

// ✅ Formatear números grandes
export const formatNumber = (value) => {
  if (value >= 1000000) {
    return `${(value / 1000000).toFixed(1)}M`
  }
  if (value >= 1000) {
    return `${(value / 1000).toFixed(1)}k`
  }
  return value?.toString() || '0'
}

// ✅ Calcular tendencia entre dos valores
export const calculateTrend = (current, previous) => {
  if (!previous || previous === 0) {
    return { direction: 'stable', percentage: 0 }
  }
  
  const change = ((current - previous) / previous) * 100
  
  return {
    direction: change > 5 ? 'up' : change < -5 ? 'down' : 'stable',
    percentage: Math.abs(change).toFixed(1),
    value: change
  }
}

// ✅ Generar datos de ejemplo para gráficos
export const generateMockChartData = (type, days = 7) => {
  const data = []
  
  for (let i = days - 1; i >= 0; i--) {
    const date = subDays(new Date(), i)
    
    switch (type) {
      case 'occupancy':
        data.push({
          day: format(date, 'EEE', { locale: es }),
          date: format(date, 'yyyy-MM-dd'),
          ocupadas: Math.floor(Math.random() * 20) + 15,
          disponibles: Math.floor(Math.random() * 10) + 5,
          mantenimiento: Math.floor(Math.random() * 3)
        })
        break
        
      case 'revenue':
        const baseRevenue = 2500
        const variance = Math.random() * 1000 - 500
        data.push({
          fecha: format(date, 'd'),
          fullDate: format(date, 'yyyy-MM-dd'),
          ingresos: Math.max(1000, baseRevenue + variance),
          gastos: Math.floor(Math.random() * 800) + 400
        })
        break
        
      case 'checkins':
        data.push({
          date: format(date, 'yyyy-MM-dd'),
          checkins: Math.floor(Math.random() * 8) + 2,
          checkouts: Math.floor(Math.random() * 6) + 1
        })
        break
        
      default:
        break
    }
  }
  
  return data
}

// ✅ Clasificar alertas por prioridad
export const sortAlertsByPriority = (alerts) => {
  const priorityOrder = { high: 3, medium: 2, low: 1 }
  
  return alerts.sort((a, b) => {
    const aPriority = priorityOrder[a.priority] || 1
    const bPriority = priorityOrder[b.priority] || 1
    return bPriority - aPriority
  })
}

// ✅ Generar alertas automáticas basadas en estadísticas
export const generateAutomaticAlerts = (stats) => {
  const alerts = []
  const now = new Date()
  
  // Alerta de stock bajo
  if (stats.lowStockItems > 0) {
    alerts.push({
      id: 'low_stock_auto',
      type: 'warning',
      title: 'Stock bajo',
      message: `${stats.lowStockItems} productos requieren reposición urgente`,
      priority: stats.lowStockItems > 5 ? 'high' : 'medium',
      timestamp: now.toISOString(),
      action: { type: 'navigate', path: '/supplies' },
      autoGenerated: true
    })
  }
  
  // Alerta de reservas pendientes
  if (stats.pendingReservations > 5) {
    alerts.push({
      id: 'pending_reservations_auto',
      type: 'info',
      title: 'Muchas reservas pendientes',
      message: `${stats.pendingReservations} reservas requieren confirmación`,
      priority: 'medium',
      timestamp: now.toISOString(),
      action: { type: 'navigate', path: '/reservations' },
      autoGenerated: true
    })
  }
  
  // Alerta de ocupación crítica
  if (stats.availableRooms === 0 && stats.totalRooms > 0) {
    alerts.push({
      id: 'full_occupancy_auto',
      type: 'warning',
      title: 'Hotel completo',
      message: 'No hay habitaciones disponibles',
      priority: 'high',
      timestamp: now.toISOString(),
      action: { type: 'navigate', path: '/rooms' },
      autoGenerated: true
    })
  }
  
  // Alerta de alta ocupación (positiva)
  const occupancyRate = stats.totalRooms > 0 
    ? (stats.occupiedRooms / stats.totalRooms) * 100 
    : 0
    
  if (occupancyRate >= 90) {
    alerts.push({
      id: 'high_occupancy_auto',
      type: 'success',
      title: 'Excelente ocupación',
      message: `Ocupación del ${occupancyRate.toFixed(0)}% - ¡Felicidades!`,
      priority: 'low',
      timestamp: now.toISOString(),
      autoGenerated: true
    })
  }
  
  // Alerta de mantenimiento requerido
  if (stats.maintenanceRooms > 0) {
    alerts.push({
      id: 'maintenance_rooms_auto',
      type: 'error',
      title: 'Habitaciones en mantenimiento',
      message: `${stats.maintenanceRooms} habitaciones requieren atención`,
      priority: 'high',
      timestamp: now.toISOString(),
      action: { type: 'navigate', path: '/rooms' },
      autoGenerated: true
    })
  }
  
  return sortAlertsByPriority(alerts)
}

// ✅ Calcular métricas de rendimiento
export const calculatePerformanceMetrics = (stats, chartData) => {
  // ADR (Average Daily Rate)
  const adr = stats.todayRevenue && stats.occupiedRooms > 0
    ? stats.todayRevenue / stats.occupiedRooms
    : 0
  
  // RevPAR (Revenue per Available Room)
  const revpar = stats.todayRevenue && stats.totalRooms > 0
    ? stats.todayRevenue / stats.totalRooms
    : 0
  
  // Tasa de ocupación
  const occupancyRate = stats.totalRooms > 0
    ? (stats.occupiedRooms / stats.totalRooms) * 100
    : 0
  
  // Promedio de estadía (simulado)
  const avgStayLength = 2.3
  
  // Ingresos proyectados para el mes (simulado)
  const dailyAvg = chartData.revenueTrend?.length > 0
    ? chartData.revenueTrend.reduce((sum, day) => sum + day.ingresos, 0) / chartData.revenueTrend.length
    : stats.todayRevenue
  
  const monthlyProjection = dailyAvg * 30
  
  return {
    adr: formatCurrency(adr),
    revpar: formatCurrency(revpar),
    occupancyRate: formatPercentage(occupancyRate),
    avgStayLength: `${avgStayLength} días`,
    monthlyProjection: formatCurrency(monthlyProjection),
    metrics: {
      adr: adr,
      revpar: revpar,
      occupancyRate: occupancyRate,
      avgStayLength: avgStayLength
    }
  }
}

// ✅ Validar datos del dashboard
export const validateDashboardData = (data) => {
  const errors = []
  
  if (!data.stats) {
    errors.push('Faltan estadísticas principales')
  } else {
    if (data.stats.totalRooms < 0) {
      errors.push('Total de habitaciones inválido')
    }
    if (data.stats.occupiedRooms > data.stats.totalRooms) {
      errors.push('Habitaciones ocupadas no puede ser mayor al total')
    }
    if (data.stats.todayRevenue < 0) {
      errors.push('Ingresos no pueden ser negativos')
    }
  }
  
  if (!data.chartData || !Array.isArray(data.chartData.occupancyTrend)) {
    errors.push('Datos de gráficos inválidos')
  }
  
  return {
    isValid: errors.length === 0,
    errors
  }
}

// ✅ Formatear tiempo relativo
export const formatRelativeTime = (date) => {
  const now = new Date()
  const diffInMinutes = Math.floor((now - new Date(date)) / (1000 * 60))
  
  if (diffInMinutes < 1) return 'Ahora mismo'
  if (diffInMinutes < 60) return `Hace ${diffInMinutes} min`
  
  const diffInHours = Math.floor(diffInMinutes / 60)
  if (diffInHours < 24) return `Hace ${diffInHours}h`
  
  const diffInDays = Math.floor(diffInHours / 24)
  if (diffInDays < 7) return `Hace ${diffInDays} días`
  
  return format(new Date(date), 'dd/MM/yyyy')
}

// ✅ Obtener color para métricas basado en el valor
export const getMetricColor = (type, value, thresholds = {}) => {
  const defaultThresholds = {
    occupancy: { good: 80, warning: 60 },
    revenue: { good: 2000, warning: 1000 },
    satisfaction: { good: 4.5, warning: 3.5 }
  }
  
  const threshold = thresholds[type] || defaultThresholds[type]
  if (!threshold) return 'text-gray-600'
  
  if (value >= threshold.good) return 'text-green-600'
  if (value >= threshold.warning) return 'text-yellow-600'
  return 'text-red-600'
}

// ✅ Generar configuración de colores para gráficos
export const getChartColors = (theme = 'default') => {
  const themes = {
    default: {
      primary: '#3b82f6',
      secondary: '#ef4444', 
      success: '#22c55e',
      warning: '#f59e0b',
      info: '#8b5cf6'
    },
    dark: {
      primary: '#60a5fa',
      secondary: '#f87171',
      success: '#4ade80', 
      warning: '#fbbf24',
      info: '#a78bfa'
    }
  }
  
  return themes[theme] || themes.default
}

// ✅ Procesar datos de actividad reciente
export const processRecentActivity = (rawActivity) => {
  return rawActivity
    .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
    .slice(0, 10) // Solo los 10 más recientes
    .map(activity => ({
      ...activity,
      timeAgo: formatRelativeTime(activity.timestamp),
      formattedTime: format(new Date(activity.timestamp), 'HH:mm')
    }))
}

// ✅ Calcular tendencias de ocupación
export const calculateOccupancyTrends = (occupancyData) => {
  if (!occupancyData || occupancyData.length < 2) {
    return { trend: 'stable', change: 0 }
  }
  
  const recent = occupancyData.slice(-3) // Últimos 3 días
  const older = occupancyData.slice(-6, -3) // 3 días anteriores
  
  const recentAvg = recent.reduce((sum, day) => 
    sum + (day.ocupadas / (day.ocupadas + day.disponibles + (day.mantenimiento || 0))), 0
  ) / recent.length
  
  const olderAvg = older.length > 0 ? older.reduce((sum, day) => 
    sum + (day.ocupadas / (day.ocupadas + day.disponibles + (day.mantenimiento || 0))), 0
  ) / older.length : recentAvg
  
  const change = ((recentAvg - olderAvg) / olderAvg) * 100
  
  return {
    trend: change > 5 ? 'up' : change < -5 ? 'down' : 'stable',
    change: Math.abs(change).toFixed(1),
    direction: change > 0 ? 'positive' : change < 0 ? 'negative' : 'neutral'
  }
}

// ✅ Generar recomendaciones automáticas
export const generateRecommendations = (stats, trends) => {
  const recommendations = []
  
  const occupancyRate = stats.totalRooms > 0 
    ? (stats.occupiedRooms / stats.totalRooms) * 100 
    : 0
  
  // Recomendaciones de ocupación
  if (occupancyRate < 50) {
    recommendations.push({
      type: 'marketing',
      priority: 'high',
      title: 'Mejorar ocupación',
      description: 'Considera implementar promociones para aumentar la ocupación',
      actions: ['Crear oferta especial', 'Revisar precios', 'Campaña en redes sociales']
    })
  } else if (occupancyRate > 90) {
    recommendations.push({
      type: 'pricing',
      priority: 'medium',
      title: 'Optimizar precios',
      description: 'Alta demanda detectada, considera aumentar tarifas',
      actions: ['Revisar precios para fechas futuras', 'Implementar tarifas dinámicas']
    })
  }
  
  // Recomendaciones de mantenimiento
  if (stats.maintenanceRooms > 0) {
    recommendations.push({
      type: 'maintenance',
      priority: 'high',
      title: 'Habitaciones en mantenimiento',
      description: `${stats.maintenanceRooms} habitaciones fuera de servicio`,
      actions: ['Priorizar reparaciones', 'Contactar equipo de mantenimiento']
    })
  }
  
  // Recomendaciones de inventario
  if (stats.lowStockItems > 3) {
    recommendations.push({
      type: 'inventory',
      priority: 'medium',
      title: 'Revisar inventario',
      description: 'Múltiples productos con stock bajo',
      actions: ['Generar orden de compra', 'Contactar proveedores']
    })
  }
  
  // Recomendaciones de reservas
  if (stats.pendingReservations > 5) {
    recommendations.push({
      type: 'operations',
      priority: 'medium',
      title: 'Confirmar reservas',
      description: 'Muchas reservas pendientes de confirmación',
      actions: ['Revisar reservas pendientes', 'Contactar huéspedes']
    })
  }
  
  return recommendations.sort((a, b) => {
    const priorityOrder = { high: 3, medium: 2, low: 1 }
    return priorityOrder[b.priority] - priorityOrder[a.priority]
  })
}

// ✅ Exportar datos del dashboard
export const exportDashboardData = (dashboardData, format = 'json') => {
  const exportData = {
    timestamp: new Date().toISOString(),
    branch: dashboardData.primaryBranch?.name,
    stats: dashboardData.stats,
    metrics: calculatePerformanceMetrics(dashboardData.stats, dashboardData.chartData),
    alerts: dashboardData.alerts?.filter(alert => !alert.autoGenerated),
    recommendations: generateRecommendations(dashboardData.stats)
  }
  
  switch (format) {
    case 'csv':
      return convertToCSV(exportData.stats)
    case 'xlsx':
      return exportData // Se procesaría con una librería como xlsx
    default:
      return JSON.stringify(exportData, null, 2)
  }
}

// ✅ Convertir estadísticas a CSV
const convertToCSV = (stats) => {
  const headers = Object.keys(stats).join(',')
  const values = Object.values(stats).join(',')
  return `${headers}\n${values}`
}

// ✅ Configuración de actualización automática
export const getAutoRefreshConfig = (userPreferences = {}) => {
  return {
    enabled: userPreferences.autoRefresh !== false,
    interval: userPreferences.refreshInterval || 5 * 60 * 1000, // 5 minutos por defecto
    onlyWhenVisible: true, // Solo refrescar cuando la pestaña está visible
    maxRetries: 3,
    retryDelay: 30000 // 30 segundos entre reintentos
  }
}

// ✅ Detectar cambios significativos en los datos
export const detectSignificantChanges = (previousStats, currentStats) => {
  if (!previousStats) return []
  
  const changes = []
  const thresholds = {
    occupiedRooms: 2,
    todayRevenue: 500,
    pendingReservations: 3
  }
  
  Object.keys(thresholds).forEach(key => {
    const prev = previousStats[key] || 0
    const curr = currentStats[key] || 0
    const diff = Math.abs(curr - prev)
    
    if (diff >= thresholds[key]) {
      changes.push({
        metric: key,
        previous: prev,
        current: curr,
        change: curr - prev,
        percentage: prev > 0 ? ((curr - prev) / prev) * 100 : 0
      })
    }
  })
  
  return changes
}

// ✅ Utilidades para notificaciones
export const shouldShowNotification = (change, userPreferences = {}) => {
  if (!userPreferences.notifications) return false
  
  const importantMetrics = ['occupiedRooms', 'maintenanceRooms', 'lowStockItems']
  return importantMetrics.includes(change.metric) && Math.abs(change.change) > 0
}

// ✅ Generar resumen ejecutivo
export const generateExecutiveSummary = (stats, trends, timeframe = 'daily') => {
  const occupancyRate = stats.totalRooms > 0 
    ? (stats.occupiedRooms / stats.totalRooms) * 100 
    : 0
    
  const performance = occupancyRate >= 80 ? 'excelente' : 
                    occupancyRate >= 60 ? 'bueno' : 'bajo'
  
  return {
    overview: `Rendimiento ${performance} con ${occupancyRate.toFixed(0)}% de ocupación`,
    keyMetrics: [
      `${stats.occupiedRooms} de ${stats.totalRooms} habitaciones ocupadas`,
      `${formatCurrency(stats.todayRevenue)} en ingresos del día`,
      `${stats.todayCheckins} check-ins y ${stats.todayCheckouts} check-outs`
    ],
    alerts: stats.pendingReservations > 0 || stats.lowStockItems > 0 || stats.maintenanceRooms > 0,
    trend: trends?.occupancy || 'stable',
    recommendation: generateRecommendations(stats, trends)[0]?.description || 'Mantener operaciones actuales'
  }
}